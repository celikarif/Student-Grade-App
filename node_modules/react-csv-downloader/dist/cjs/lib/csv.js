"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const newLine = '\r\n';
const raf = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : process.nextTick;
const makeWrapper = (wrapChar) => (str) => `${wrapChar}${str}${wrapChar}`;
const makeResolver = (resolve, newLineAtEnd) => (content) => {
    if (newLineAtEnd) {
        content.push('');
    }
    resolve(content.join(newLine));
};
const identityMapping = (arr, initialMapping) => arr.reduce((acc, k) => {
    acc.map[k] = k;
    acc.order.push(k);
    return acc;
}, initialMapping);
const extractHeaderFromData = (datas) => datas.reduce((acc, v) => {
    return Array.isArray(v) ? acc : identityMapping(Object.keys(v), acc);
}, {
    order: [],
    map: {},
});
const extractHeaderFromColumns = (columns) => columns.reduce((acc, v) => {
    var _a;
    let id, value;
    if (typeof v === 'string') {
        id = v;
        value = v;
    }
    else {
        id = v.id;
        value = (_a = v.displayName) !== null && _a !== void 0 ? _a : v.id;
    }
    acc.map[id] = value;
    acc.order.push(id);
    return acc;
}, { order: [], map: {} });
function toChunks(arr, chunkSize) {
    return [...Array(Math.ceil(arr.length / chunkSize))].reduce((acc, _, i) => {
        const begin = i * chunkSize;
        return acc.concat([arr.slice(begin, begin + chunkSize)]);
    }, []);
}
const createChunkProcessor = (resolve, wrap, content, datas, columnOrder, separator, chunkSize) => {
    const chunks = toChunks(datas, chunkSize);
    let i = 0;
    return function processChunk() {
        if (i >= chunks.length) {
            resolve(content);
            return;
        }
        const chunk = chunks[i];
        // @ts-expect-error
        const asArray = Array.isArray(chunk[0]) && !columnOrder.some((k) => typeof chunk[0][k] !== 'undefined');
        i += 1;
        chunk
            // @ts-expect-error
            .map((v) => (asArray ? v : columnOrder.map((k) => { var _a; return (_a = v[k]) !== null && _a !== void 0 ? _a : ''; })))
            .forEach((v) => {
            content.push(v.map(wrap).join(separator));
        });
        raf(processChunk);
    };
};
function csv({ columns, datas, separator = ',', noHeader = false, wrapColumnChar = '', newLineAtEnd = false, chunkSize = 1000, title = '', }) {
    return __awaiter(this, void 0, void 0, function* () {
        // eslint-disable-next-line no-async-promise-executor
        return new Promise((_resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            const resolve = makeResolver(_resolve, newLineAtEnd);
            const wrap = makeWrapper(wrapColumnChar);
            try {
                datas = typeof datas === 'function' ? yield datas() : yield datas;
                if (!Array.isArray(datas)) {
                    return _resolve();
                }
                const { map, order } = columns ? extractHeaderFromColumns(columns) : extractHeaderFromData(datas);
                const content = [];
                if (!noHeader) {
                    const headerNames = order.map((id) => map[id]);
                    if (headerNames.length > 0) {
                        if (title !== '') {
                            content.push(title);
                        }
                        content.push(headerNames.map(wrap).join(separator));
                    }
                }
                const processChunk = createChunkProcessor(resolve, wrap, content, datas, order, separator, chunkSize);
                raf(processChunk);
            }
            catch (err) {
                return reject(err);
            }
        }));
    });
}
exports.default = csv;
//# sourceMappingURL=csv.js.map