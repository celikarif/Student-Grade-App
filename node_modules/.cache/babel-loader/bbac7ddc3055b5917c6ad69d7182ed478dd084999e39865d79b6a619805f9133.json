{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nconst newLine = '\\r\\n';\nconst raf = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : process.nextTick;\nconst makeWrapper = wrapChar => str => `${wrapChar}${str}${wrapChar}`;\nconst makeResolver = (resolve, newLineAtEnd) => content => {\n  if (newLineAtEnd) {\n    content.push('');\n  }\n  resolve(content.join(newLine));\n};\nconst identityMapping = (arr, initialMapping) => arr.reduce((acc, k) => {\n  acc.map[k] = k;\n  acc.order.push(k);\n  return acc;\n}, initialMapping);\nconst extractHeaderFromData = datas => datas.reduce((acc, v) => {\n  return Array.isArray(v) ? acc : identityMapping(Object.keys(v), acc);\n}, {\n  order: [],\n  map: {}\n});\nconst extractHeaderFromColumns = columns => columns.reduce((acc, v) => {\n  var _a;\n  let id, value;\n  if (typeof v === 'string') {\n    id = v;\n    value = v;\n  } else {\n    id = v.id;\n    value = (_a = v.displayName) !== null && _a !== void 0 ? _a : v.id;\n  }\n  acc.map[id] = value;\n  acc.order.push(id);\n  return acc;\n}, {\n  order: [],\n  map: {}\n});\nfunction toChunks(arr, chunkSize) {\n  return [...Array(Math.ceil(arr.length / chunkSize))].reduce((acc, _, i) => {\n    const begin = i * chunkSize;\n    return acc.concat([arr.slice(begin, begin + chunkSize)]);\n  }, []);\n}\nconst createChunkProcessor = (resolve, wrap, content, datas, columnOrder, separator, chunkSize) => {\n  const chunks = toChunks(datas, chunkSize);\n  let i = 0;\n  return function processChunk() {\n    if (i >= chunks.length) {\n      resolve(content);\n      return;\n    }\n    const chunk = chunks[i];\n    // @ts-expect-error\n    const asArray = Array.isArray(chunk[0]) && !columnOrder.some(k => typeof chunk[0][k] !== 'undefined');\n    i += 1;\n    chunk\n    // @ts-expect-error\n    .map(v => asArray ? v : columnOrder.map(k => {\n      var _a;\n      return (_a = v[k]) !== null && _a !== void 0 ? _a : '';\n    })).forEach(v => {\n      content.push(v.map(wrap).join(separator));\n    });\n    raf(processChunk);\n  };\n};\nexport default function csv(_ref) {\n  let {\n    columns,\n    datas,\n    separator = ',',\n    noHeader = false,\n    wrapColumnChar = '',\n    newLineAtEnd = false,\n    chunkSize = 1000,\n    title = ''\n  } = _ref;\n  return __awaiter(this, void 0, void 0, function* () {\n    // eslint-disable-next-line no-async-promise-executor\n    return new Promise((_resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n      const resolve = makeResolver(_resolve, newLineAtEnd);\n      const wrap = makeWrapper(wrapColumnChar);\n      try {\n        datas = typeof datas === 'function' ? yield datas() : yield datas;\n        if (!Array.isArray(datas)) {\n          return _resolve();\n        }\n        const {\n          map,\n          order\n        } = columns ? extractHeaderFromColumns(columns) : extractHeaderFromData(datas);\n        const content = [];\n        if (!noHeader) {\n          const headerNames = order.map(id => map[id]);\n          if (headerNames.length > 0) {\n            if (title !== '') {\n              content.push(title);\n            }\n            content.push(headerNames.map(wrap).join(separator));\n          }\n        }\n        const processChunk = createChunkProcessor(resolve, wrap, content, datas, order, separator, chunkSize);\n        raf(processChunk);\n      } catch (err) {\n        return reject(err);\n      }\n    }));\n  });\n}","map":{"version":3,"mappings":"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","names":["newLine","raf","requestAnimationFrame","process","nextTick","makeWrapper","wrapChar","str","makeResolver","resolve","newLineAtEnd","content","push","join","identityMapping","arr","initialMapping","reduce","acc","k","map","order","extractHeaderFromData","datas","v","Array","isArray","Object","keys","extractHeaderFromColumns","columns","id","value","displayName","toChunks","chunkSize","Math","ceil","length","_","i","begin","concat","slice","createChunkProcessor","wrap","columnOrder","separator","chunks","processChunk","chunk","asArray","some","forEach","csv","noHeader","wrapColumnChar","title","Promise","_resolve","reject","__awaiter","headerNames","err"],"sources":["C:\\Users\\arif\\Desktop\\Student_Grade_App\\frontend\\student_grade_app\\node_modules\\react-csv-downloader\\src\\lib\\csv.ts"],"sourcesContent":["export interface IColumn {\n  displayName?: string\n  id: string\n}\n\nexport type ColumnsDefinition = (string | IColumn)[]\nexport type Columns = ColumnsDefinition | undefined | false\nexport type Datas = (string[] | { [key: string]: string | null | undefined })[]\n\ninterface Header {\n  order: string[]\n  map: Record<string, string>\n}\n\nconst newLine = '\\r\\n'\nconst raf = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : process.nextTick\n\nconst makeWrapper = (wrapChar: string) => (str: string) => `${wrapChar}${str}${wrapChar}`\nconst makeResolver = (resolve: (result: string) => unknown, newLineAtEnd: boolean) => (content: string[]) => {\n  if (newLineAtEnd) {\n    content.push('')\n  }\n\n  resolve(content.join(newLine))\n}\n\nconst identityMapping = (arr: string[], initialMapping: Header): Header =>\n  arr.reduce((acc, k) => {\n    acc.map[k] = k\n    acc.order.push(k)\n    return acc\n  }, initialMapping)\n\nconst extractHeaderFromData = (datas: Datas): Header =>\n  datas.reduce(\n    (acc: Header, v) => {\n      return Array.isArray(v) ? acc : identityMapping(Object.keys(v), acc)\n    },\n    {\n      order: [],\n      map: {},\n    }\n  )\n\nconst extractHeaderFromColumns = (columns: ColumnsDefinition): Header =>\n  columns.reduce(\n    (acc: Header, v) => {\n      let id, value\n      if (typeof v === 'string') {\n        id = v\n        value = v\n      } else {\n        id = v.id\n        value = v.displayName ?? v.id\n      }\n      acc.map[id] = value\n      acc.order.push(id)\n      return acc\n    },\n    { order: [], map: {} }\n  )\n\nfunction toChunks<T>(arr: T[], chunkSize: number): T[][] {\n  return [...Array(Math.ceil(arr.length / chunkSize))].reduce((acc, _, i) => {\n    const begin = i * chunkSize\n    return acc.concat([arr.slice(begin, begin + chunkSize)])\n  }, [])\n}\n\nconst createChunkProcessor = (\n  resolve: ReturnType<typeof makeResolver>,\n  wrap: ReturnType<typeof makeWrapper>,\n  content: string[],\n  datas: Datas,\n  columnOrder: string[],\n  separator: string,\n  chunkSize: number\n) => {\n  const chunks = toChunks(datas, chunkSize)\n  let i = 0\n  return function processChunk() {\n    if (i >= chunks.length) {\n      resolve(content)\n      return\n    }\n\n    const chunk = chunks[i]\n    // @ts-expect-error\n    const asArray = Array.isArray(chunk[0]) && !columnOrder.some((k) => typeof chunk[0][k] !== 'undefined')\n    i += 1\n    chunk\n      // @ts-expect-error\n      .map((v) => (asArray ? v : columnOrder.map((k) => v[k] ?? '')) as string[])\n      .forEach((v) => {\n        content.push(v.map(wrap).join(separator))\n      })\n\n    raf(processChunk)\n  }\n}\n\nexport interface ICsvProps {\n  columns?: Columns\n  datas: Datas | (() => Datas) | (() => Promise<Datas>) | Promise<Datas>\n  separator?: string\n  noHeader?: boolean\n  wrapColumnChar?: string\n  newLineAtEnd?: boolean\n  chunkSize?: number\n  title?: string\n}\n\nexport default async function csv({\n  columns,\n  datas,\n  separator = ',',\n  noHeader = false,\n  wrapColumnChar = '',\n  newLineAtEnd = false,\n  chunkSize = 1000,\n  title = '',\n}: ICsvProps) {\n  // eslint-disable-next-line no-async-promise-executor\n  return new Promise<void | string>(async (_resolve, reject) => {\n    const resolve = makeResolver(_resolve, newLineAtEnd)\n    const wrap = makeWrapper(wrapColumnChar)\n\n    try {\n      datas = typeof datas === 'function' ? await datas() : await datas\n      if (!Array.isArray(datas)) {\n        return _resolve()\n      }\n\n      const { map, order }: Header = columns ? extractHeaderFromColumns(columns) : extractHeaderFromData(datas)\n\n      const content: string[] = []\n\n      if (!noHeader) {\n        const headerNames = order.map((id) => map[id])\n        if (headerNames.length > 0) {\n          if (title !== '') {\n            content.push(title)\n          }\n          content.push(headerNames.map(wrap).join(separator))\n        }\n      }\n\n      const processChunk = createChunkProcessor(resolve, wrap, content, datas, order, separator, chunkSize)\n\n      raf(processChunk)\n    } catch (err) {\n      return reject(err)\n    }\n  })\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}